#!/usr/bin/env python3
"""
SWOS420 ‚Äî Set Token URIs On-Chain

Reads the metadata-manifest.json (generated by the Arweave uploader)
and calls setTokenURIBatch() on the SWOSPlayerNFT contract to set
each token's URI to its Arweave ar:// address.

Usage:
    python scripts/arweave/set_token_uris.py                       # Use defaults
    python scripts/arweave/set_token_uris.py --manifest data/metadata-manifest.json
    python scripts/arweave/set_token_uris.py --dry-run              # Just show what would happen
    python scripts/arweave/set_token_uris.py --batch-size 20        # Set batch size

Env vars required:
    PRIVATE_KEY         ‚Äî deployer wallet private key
    RPC_URL             ‚Äî Base Sepolia RPC URL
    PLAYER_NFT_ADDRESS  ‚Äî SWOSPlayerNFT contract address
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from pathlib import Path

from dotenv import load_dotenv

ROOT = Path(__file__).resolve().parent.parent.parent
load_dotenv(ROOT / ".env")
load_dotenv(ROOT / "contracts" / ".env")

# ‚îÄ‚îÄ Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

DEFAULT_MANIFEST = ROOT / "data" / "metadata-manifest.json"
DEFAULT_DEPLOYMENTS = ROOT / "contracts" / "deployments" / "base-sepolia.json"

# Minimal ABI for setTokenURIBatch + tokenURI
SWOS_PLAYER_NFT_ABI = [
    {
        "inputs": [
            {"internalType": "uint256[]", "name": "tokenIds", "type": "uint256[]"},
            {"internalType": "string[]", "name": "uris", "type": "string[]"},
        ],
        "name": "setTokenURIBatch",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [
            {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
            {"internalType": "string", "name": "uri", "type": "string"},
        ],
        "name": "setTokenURI",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
    },
    {
        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
        "name": "tokenURI",
        "outputs": [{"internalType": "string", "name": "", "type": "string"}],
        "stateMutability": "view",
        "type": "function",
    },
    {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function",
    },
]


def get_nft_address() -> str:
    """Get the NFT contract address from env or deployments file."""
    addr = os.environ.get("PLAYER_NFT_ADDRESS")
    if addr:
        return addr

    if DEFAULT_DEPLOYMENTS.exists():
        with open(DEFAULT_DEPLOYMENTS) as f:
            deployments = json.load(f)
        addr = deployments.get("contracts", {}).get("SWOSPlayerNFT", {}).get("address")
        if addr:
            return addr

    print("‚ùå PLAYER_NFT_ADDRESS not set and not found in deployments file")
    sys.exit(1)


def main() -> None:
    parser = argparse.ArgumentParser(description="Set token URIs on SWOSPlayerNFT from Arweave manifest")
    parser.add_argument("--manifest", type=str, default=str(DEFAULT_MANIFEST), help="Path to metadata-manifest.json")
    parser.add_argument("--batch-size", type=int, default=25, help="Tokens per batch transaction")
    parser.add_argument("--dry-run", action="store_true", help="Preview without sending transactions")
    parser.add_argument("--verify", action="store_true", help="After setting, verify each tokenURI on-chain")
    args = parser.parse_args()

    # Load manifest
    manifest_path = Path(args.manifest)
    if not manifest_path.exists():
        print(f"‚ùå Manifest not found at {manifest_path}")
        print("   Run the Arweave uploader first: cd scripts/arweave && npx tsx upload_metadata.ts")
        sys.exit(1)

    with open(manifest_path) as f:
        manifest = json.load(f)

    print("üèüÔ∏è  SWOS420 Token URI Setter")
    print(f"   Mode: {'DRY RUN' if args.dry_run else 'LIVE'}")
    print(f"   Players: {len(manifest)}")
    print(f"   Batch size: {args.batch_size}")
    print()

    if args.dry_run:
        for entry in manifest:
            print(f"   #{entry['tokenId']}: {entry['metadataUri']}")
        print(f"\n‚úÖ Dry run: {len(manifest)} URIs would be set. No transactions sent.")
        return

    # Connect to chain
    from web3 import Web3

    rpc_url = os.environ.get("RPC_URL") or os.environ.get("BASE_SEPOLIA_RPC_URL")
    private_key = os.environ.get("PRIVATE_KEY") or os.environ.get("DEPLOYER_PRIVATE_KEY")

    if not rpc_url:
        print("‚ùå RPC_URL or BASE_SEPOLIA_RPC_URL not set in .env")
        sys.exit(1)
    if not private_key:
        print("‚ùå PRIVATE_KEY or DEPLOYER_PRIVATE_KEY not set in .env")
        sys.exit(1)

    w3 = Web3(Web3.HTTPProvider(rpc_url))
    if not w3.is_connected():
        print(f"‚ùå Cannot connect to RPC: {rpc_url}")
        sys.exit(1)

    account = w3.eth.account.from_key(private_key)
    print(f"   Wallet: {account.address}")
    print(f"   Chain: {w3.eth.chain_id}")

    nft_address = get_nft_address()
    nft = w3.eth.contract(address=Web3.to_checksum_address(nft_address), abi=SWOS_PLAYER_NFT_ABI)
    print(f"   Contract: {nft_address}")
    print()

    # Process in batches
    for batch_start in range(0, len(manifest), args.batch_size):
        batch = manifest[batch_start : batch_start + args.batch_size]
        token_ids = [entry["tokenId"] for entry in batch]
        uris = [entry["metadataUri"] for entry in batch]

        print(f"   ‚öΩ Batch {batch_start // args.batch_size + 1}: tokens {token_ids[0]}..{token_ids[-1]}")

        nonce = w3.eth.get_transaction_count(account.address)
        tx = nft.functions.setTokenURIBatch(token_ids, uris).build_transaction(
            {
                "from": account.address,
                "nonce": nonce,
                "gas": 500_000 + 50_000 * len(batch),  # ~50k gas per URI set
                "maxFeePerGas": w3.eth.gas_price * 2,
                "maxPriorityFeePerGas": w3.to_wei(0.001, "gwei"),
            }
        )

        signed = account.sign_transaction(tx)
        tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)
        print(f"      üì§ Tx: {tx_hash.hex()}")

        receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
        if receipt.status == 1:
            print(f"      ‚úÖ Confirmed in block {receipt.blockNumber}")
        else:
            print("      ‚ùå Transaction FAILED!")
            sys.exit(1)

    print(f"\nüéâ All {len(manifest)} token URIs set on-chain!")

    # Verify
    if args.verify:
        print("\nüîç Verifying URIs on-chain...")
        errors = 0
        for entry in manifest:
            on_chain_uri = nft.functions.tokenURI(entry["tokenId"]).call()
            expected = entry["metadataUri"]
            if on_chain_uri == expected:
                print(f"   ‚úÖ #{entry['tokenId']}: matches")
            else:
                print(f"   ‚ùå #{entry['tokenId']}: MISMATCH")
                print(f"      Expected: {expected}")
                print(f"      Got:      {on_chain_uri}")
                errors += 1

        if errors:
            print(f"\n‚ö†Ô∏è  {errors} mismatches found!")
        else:
            print(f"\n‚úÖ All {len(manifest)} URIs verified on-chain!")


if __name__ == "__main__":
    main()
